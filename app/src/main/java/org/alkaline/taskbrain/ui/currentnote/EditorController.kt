package org.alkaline.taskbrain.ui.currentnote

import androidx.compose.runtime.Composable
import org.alkaline.taskbrain.ui.currentnote.undo.CommandType
import org.alkaline.taskbrain.ui.currentnote.undo.UndoManager
import org.alkaline.taskbrain.ui.currentnote.undo.AlarmSnapshot
import org.alkaline.taskbrain.ui.currentnote.undo.UndoSnapshot
import org.alkaline.taskbrain.ui.currentnote.util.LinePrefixes
import androidx.compose.runtime.remember
import androidx.compose.ui.platform.ClipboardManager
import androidx.compose.ui.text.AnnotatedString

/**
 * Operation types for discrete editing actions.
 *
 * NOTE: TYPING, ENTER, and LINE_MERGE are NOT in this enum because they have
 * specialized handling:
 * - TYPING: Implicit via focus changes (already works correctly)
 * - ENTER: Already correctly handled in splitLine()
 * - LINE_MERGE: Already correctly handled in mergeToPreviousLine()/mergeNextLine()
 */
enum class OperationType {
    COMMAND_BULLET,   // Each press is separate undo step
    COMMAND_CHECKBOX, // Each press is separate undo step
    COMMAND_INDENT,   // Consecutive indent/unindent are grouped
    PASTE,            // Always own undo step
    CUT,              // Always own undo step
    DELETE_SELECTION, // Always own undo step
    CHECKBOX_TOGGLE,  // Gutter checkbox toggle - same as COMMAND_CHECKBOX
    ALARM_SYMBOL,     // Alarm symbol insertion - commits pending, captures state
    MOVE_LINES,       // Consecutive moves of same lines are grouped
}

/**
 * State for move up/down buttons.
 */
data class MoveButtonState(
    val isEnabled: Boolean,
    val isWarning: Boolean
)

/**
 * Centralized controller for all editor state modifications.
 *
 * This is the SINGLE CHANNEL through which all state changes flow.
 * Benefits:
 * - Single source of truth
 * - Predictable state transitions
 * - Easy debugging (all changes go through one place)
 * - Proper notification of changes
 *
 * Usage:
 * - ImeState forwards all IME events here
 * - UI components call controller methods instead of directly modifying state
 * - State changes automatically trigger recomposition via stateVersion
 */
class EditorController(
    internal val state: EditorState,
    val undoManager: UndoManager = UndoManager()
) {
    // =========================================================================
    // Undo/Redo Operations
    // =========================================================================

    val canUndo: Boolean get() = undoManager.canUndo
    val canRedo: Boolean get() = undoManager.canRedo

    /**
     * Commits any pending undo state. Call at undo boundaries:
     * - Focus changes to different line
     * - Save button clicked
     * - Undo/redo button clicked
     * - Navigate away from screen
     *
     * @param continueEditing If true, sets up a new pending snapshot for subsequent
     *        typing on the current line. Use this for save operations where the user
     *        continues editing. Don't use for navigate-away or undo/redo (which handle
     *        this separately).
     */
    fun commitUndoState(continueEditing: Boolean = false) {
        undoManager.commitPendingUndoState(state)
        if (continueEditing) {
            undoManager.beginEditingLine(state, state.focusedLineIndex)
        }
    }

    /**
     * Records a command bar action for undo grouping.
     * Bullet/Checkbox: Each is a separate undo step.
     * Indent/Unindent: Consecutive presses are grouped.
     */
    fun recordCommand(type: CommandType) {
        undoManager.recordCommand(state, type)
    }

    /**
     * Call after command completes for commands that should immediately commit.
     */
    fun commitAfterCommand(type: CommandType) {
        undoManager.commitAfterCommand(state, type)
    }

    /**
     * Records that an alarm was created, for undo/redo tracking.
     * Ensures there's an undo entry to attach the alarm to.
     */
    fun recordAlarmCreation(alarm: AlarmSnapshot) {
        undoManager.recordAlarmCreation(alarm, state)
    }

    /**
     * Performs undo and restores the snapshot.
     * Returns the snapshot for alarm handling (caller deletes createdAlarm if present).
     */
    fun undo(): UndoSnapshot? {
        val snapshot = undoManager.undo(state) ?: return null
        restoreFromSnapshot(snapshot)
        // Set up pending state for subsequent typing on the restored line
        undoManager.beginEditingLine(state, state.focusedLineIndex)
        return snapshot
    }

    /**
     * Performs redo and restores the snapshot.
     * Returns the snapshot for alarm handling (caller recreates createdAlarm if present).
     */
    fun redo(): UndoSnapshot? {
        val snapshot = undoManager.redo(state) ?: return null
        restoreFromSnapshot(snapshot)
        // Set up pending state for subsequent typing on the restored line
        undoManager.beginEditingLine(state, state.focusedLineIndex)
        return snapshot
    }

    /**
     * Updates the alarm ID after redo recreates an alarm with a new ID.
     */
    fun updateLastUndoAlarmId(newId: String) {
        undoManager.updateLastUndoAlarmId(newId)
    }

    /**
     * Restores editor state from a snapshot.
     */
    private fun restoreFromSnapshot(snapshot: UndoSnapshot) {
        state.lines.clear()
        snapshot.lineContents.forEach { lineText ->
            state.lines.add(LineState(lineText))
        }
        state.focusedLineIndex = snapshot.focusedLineIndex.coerceIn(0, state.lines.lastIndex.coerceAtLeast(0))
        state.lines.getOrNull(state.focusedLineIndex)?.let { line ->
            line.updateFull(line.text, snapshot.cursorPosition.coerceIn(0, line.text.length))
        }
        state.clearSelection()
        state.requestFocusUpdate()
        state.notifyChange()
    }

    /**
     * Resets undo history. Call when loading a new note.
     */
    fun resetUndoHistory() {
        undoManager.reset()
    }

    // =========================================================================
    // Operation Executor (centralizes undo boundary management)
    // =========================================================================

    /**
     * Executes an operation with proper undo boundary handling.
     * Pre-operation: Sets up appropriate undo state based on operation type
     * Post-operation: Commits or continues pending state as appropriate
     */
    private fun <T> executeOperation(type: OperationType, action: () -> T): T {
        handlePreOperation(type)
        val result = action()
        handlePostOperation(type)
        return result
    }

    private fun handlePreOperation(type: OperationType) {
        when (type) {
            OperationType.COMMAND_BULLET, OperationType.COMMAND_CHECKBOX,
            OperationType.CHECKBOX_TOGGLE -> {
                undoManager.recordCommand(state, commandTypeFor(type))
            }
            OperationType.COMMAND_INDENT -> {
                undoManager.recordCommand(state, CommandType.INDENT)
            }
            OperationType.PASTE, OperationType.CUT, OperationType.DELETE_SELECTION -> {
                undoManager.captureStateBeforeChange(state)
            }
            OperationType.ALARM_SYMBOL -> {
                undoManager.commitPendingUndoState(state)
                undoManager.captureStateBeforeChange(state)
            }
            OperationType.MOVE_LINES -> {
                // Move lines has its own undo handling via recordMoveCommand
            }
        }
    }

    private fun handlePostOperation(type: OperationType) {
        when (type) {
            OperationType.COMMAND_BULLET, OperationType.COMMAND_CHECKBOX,
            OperationType.CHECKBOX_TOGGLE -> {
                undoManager.commitAfterCommand(state, commandTypeFor(type))
            }
            OperationType.PASTE, OperationType.CUT, OperationType.DELETE_SELECTION -> {
                undoManager.beginEditingLine(state, state.focusedLineIndex)
            }
            OperationType.COMMAND_INDENT, OperationType.ALARM_SYMBOL -> {
                // Nothing - stays pending for grouping or alarm recording happens separately
            }
            OperationType.MOVE_LINES -> {
                // Move lines has its own undo handling via recordMoveCommand/updateMoveRange
            }
        }
    }

    private fun commandTypeFor(type: OperationType): CommandType = when (type) {
        OperationType.COMMAND_BULLET -> CommandType.BULLET
        OperationType.COMMAND_CHECKBOX, OperationType.CHECKBOX_TOGGLE -> CommandType.CHECKBOX
        OperationType.COMMAND_INDENT -> CommandType.INDENT
        else -> CommandType.OTHER
    }

    // =========================================================================
    // Command Operations (moved from EditorState, wrapped with undo handling)
    // =========================================================================

    /**
     * Toggles bullet prefix on the current line.
     * Each press is a separate undo step.
     */
    fun toggleBullet() = executeOperation(OperationType.COMMAND_BULLET) {
        state.toggleBulletInternal()
    }

    /**
     * Toggles checkbox prefix on the current line.
     * Cycles: nothing → unchecked → checked → removed
     * Each press is a separate undo step.
     */
    fun toggleCheckbox() = executeOperation(OperationType.COMMAND_CHECKBOX) {
        state.toggleCheckboxInternal()
    }

    /**
     * Indents selected lines or current line.
     * Consecutive indent/unindent presses are grouped into one undo step.
     */
    fun indent() = executeOperation(OperationType.COMMAND_INDENT) {
        state.indentInternal()
    }

    /**
     * Unindents selected lines or current line.
     * Consecutive indent/unindent presses are grouped into one undo step.
     */
    fun unindent() = executeOperation(OperationType.COMMAND_INDENT) {
        state.unindentInternal()
    }

    /**
     * Pastes text, replacing selection if present.
     * Always creates its own undo step.
     */
    fun paste(text: String) = executeOperation(OperationType.PASTE) {
        state.replaceSelectionInternal(text)
    }

    /**
     * Cuts selected text to clipboard.
     * Always creates its own undo step.
     * Returns the cut text, or null if nothing was selected.
     */
    fun cutSelection(clipboard: ClipboardManager): String? {
        if (!state.hasSelection) return null
        return executeOperation(OperationType.CUT) {
            val text = state.getSelectedText()
            if (text.isNotEmpty()) {
                clipboard.setText(AnnotatedString(text))
                state.deleteSelectionInternal()
            }
            text.takeIf { it.isNotEmpty() }
        }
    }

    /**
     * Deletes selected text.
     * Always creates its own undo step.
     */
    fun deleteSelectionWithUndo() {
        if (!state.hasSelection) return
        executeOperation(OperationType.DELETE_SELECTION) {
            state.deleteSelectionInternal()
        }
    }

    /**
     * Inserts text at the end of the current line (for alarm symbol).
     * Commits pending state and creates an undo point.
     */
    fun insertAtEndOfCurrentLine(text: String) =
        executeOperation(OperationType.ALARM_SYMBOL) {
            state.insertAtEndOfCurrentLineInternal(text)
        }

    // =========================================================================
    // Move Lines Operations
    // =========================================================================

    /**
     * Gets the current state of the move up button.
     */
    fun getMoveUpState(): MoveButtonState {
        val target = state.getMoveTarget(moveUp = true)
        return MoveButtonState(
            isEnabled = target != null,
            isWarning = state.wouldOrphanChildren()
        )
    }

    /**
     * Gets the current state of the move down button.
     */
    fun getMoveDownState(): MoveButtonState {
        val target = state.getMoveTarget(moveUp = false)
        return MoveButtonState(
            isEnabled = target != null,
            isWarning = state.wouldOrphanChildren()
        )
    }

    /**
     * Moves the current line/selection up.
     * Consecutive moves of the same lines are grouped into one undo step.
     * @return true if the move was performed, false if at boundary
     */
    fun moveUp(): Boolean {
        val range = if (state.hasSelection) state.getSelectedLineRange() else state.getLogicalBlock(state.focusedLineIndex)
        val target = state.getMoveTarget(moveUp = true) ?: return false

        // Record for undo grouping (uses range BEFORE move for grouping check)
        undoManager.recordMoveCommand(state, range)

        // Perform the move
        val newRange = state.moveLinesInternal(range, target)
        if (newRange != null) {
            // Update the tracked move range to the new position
            undoManager.updateMoveRange(newRange)
            // Mark content as changed so canUndo returns true
            undoManager.markContentChanged()
        }

        return newRange != null
    }

    /**
     * Moves the current line/selection down.
     * Consecutive moves of the same lines are grouped into one undo step.
     * @return true if the move was performed, false if at boundary
     */
    fun moveDown(): Boolean {
        val range = if (state.hasSelection) state.getSelectedLineRange() else state.getLogicalBlock(state.focusedLineIndex)
        val target = state.getMoveTarget(moveUp = false) ?: return false

        // Record for undo grouping (uses range BEFORE move for grouping check)
        undoManager.recordMoveCommand(state, range)

        // Perform the move
        val newRange = state.moveLinesInternal(range, target)
        if (newRange != null) {
            // Update the tracked move range to the new position
            undoManager.updateMoveRange(newRange)
            // Mark content as changed so canUndo returns true
            undoManager.markContentChanged()
        }

        return newRange != null
    }

    /**
     * Copies selected text to clipboard without modifying state.
     */
    fun copySelection(clipboard: ClipboardManager) {
        val text = state.getSelectedText()
        if (text.isNotEmpty()) {
            clipboard.setText(AnnotatedString(text))
        }
    }

    /**
     * Clears selection and positions cursor at selection start.
     */
    fun clearSelection() {
        val selectionStart = state.selection.min
        state.clearSelection()
        setCursorFromGlobalOffset(selectionStart)
    }

    // =========================================================================
    // Text Input Operations
    // =========================================================================

    /**
     * Insert text at the current cursor position.
     * If there's a selection, replaces it.
     */
    fun insertText(lineIndex: Int, text: String) {
        // Handle newline specially
        if (text.contains('\n')) {
            val parts = text.split('\n')
            parts.forEachIndexed { index, part ->
                if (index > 0) {
                    splitLine(lineIndex + index - 1)
                }
                if (part.isNotEmpty()) {
                    insertTextAtCursor(lineIndex + index, part)
                }
            }
            return
        }

        // If there's a selection, replace it
        if (state.hasSelection) {
            state.replaceSelectionInternal(text)
            return
        }

        // Normal insert at cursor
        insertTextAtCursor(lineIndex, text)
    }

    private fun insertTextAtCursor(lineIndex: Int, text: String) {
        val line = state.lines.getOrNull(lineIndex) ?: return
        val cursorInLine = line.cursorPosition
        val newText = line.text.substring(0, cursorInLine) + text + line.text.substring(cursorInLine)
        val newCursor = cursorInLine + text.length

        line.updateFull(newText, newCursor)
        state.requestFocusUpdate()
        state.notifyChange()
    }

    /**
     * Delete backward (backspace) from the current cursor position.
     */
    fun deleteBackward(lineIndex: Int) {
        // If there's a selection, delete it
        if (state.hasSelection) {
            state.deleteSelectionInternal()
            undoManager.markContentChanged()
            return
        }

        val line = state.lines.getOrNull(lineIndex) ?: return
        val cursor = line.cursorPosition

        // At start of line content (after prefix)
        if (cursor <= line.prefix.length) {
            // Try to remove prefix character first
            if (line.prefix.isNotEmpty()) {
                val newPrefix = line.prefix.dropLast(1)
                line.updateFull(newPrefix + line.content, newPrefix.length)
                state.requestFocusUpdate()
                state.notifyChange()
                undoManager.markContentChanged()
            } else if (lineIndex > 0) {
                // Merge with previous line (creates its own undo boundary)
                mergeToPreviousLine(lineIndex)
            }
            return
        }

        // Normal delete within content
        val newText = line.text.substring(0, cursor - 1) + line.text.substring(cursor)
        line.updateFull(newText, cursor - 1)
        state.requestFocusUpdate()
        state.notifyChange()
        undoManager.markContentChanged()
    }

    /**
     * Delete forward from the current cursor position.
     */
    fun deleteForward(lineIndex: Int) {
        if (state.hasSelection) {
            state.deleteSelectionInternal()
            undoManager.markContentChanged()
            return
        }

        val line = state.lines.getOrNull(lineIndex) ?: return
        val cursor = line.cursorPosition

        // At end of line - merge with next line (creates its own undo boundary)
        if (cursor >= line.text.length) {
            if (lineIndex < state.lines.lastIndex) {
                mergeNextLine(lineIndex)
            }
            return
        }

        // Normal delete
        val newText = line.text.substring(0, cursor) + line.text.substring(cursor + 1)
        line.updateFull(newText, cursor)
        state.requestFocusUpdate()
        state.notifyChange()
        undoManager.markContentChanged()
    }

    // =========================================================================
    // Line Operations
    // =========================================================================

    /**
     * Gets the prefix for a new line based on the current line's prefix.
     * Converts checked checkboxes to unchecked.
     */
    private fun getNewLinePrefix(currentPrefix: String): String {
        return currentPrefix.replace(LinePrefixes.CHECKBOX_CHECKED, LinePrefixes.CHECKBOX_UNCHECKED)
    }

    /**
     * Creates a new line with prefix continuation and adds it after the specified line.
     * @param lineIndex Index of the current line
     * @param newLineContent Content for the new line (without prefix)
     * @param currentPrefix Prefix from the current line
     */
    private fun createNewLineWithPrefix(lineIndex: Int, newLineContent: String, currentPrefix: String) {
        val newLinePrefix = getNewLinePrefix(currentPrefix)
        val newLineText = newLinePrefix + newLineContent
        val newLineCursor = newLinePrefix.length

        state.lines.add(lineIndex + 1, LineState(newLineText, newLineCursor))
        state.focusedLineIndex = lineIndex + 1
        state.requestFocusUpdate()
        state.notifyChange()
    }

    /**
     * Split line at cursor (Enter key).
     * Continues the prefix (indentation + bullet/checkbox) on the new line.
     * Checked checkboxes become unchecked on the new line.
     *
     * Undo behavior: Enter + any subsequent typing on the new line are grouped
     * as one undo step. Typing before Enter is a separate undo step.
     */
    fun splitLine(lineIndex: Int) {
        // Prepare for structural change - commits prior typing, captures pre-split state
        undoManager.prepareForStructuralChange(state)

        state.clearSelection()
        val line = state.lines.getOrNull(lineIndex) ?: return
        val cursor = line.cursorPosition
        val prefix = line.prefix

        val beforeCursor = line.text.substring(0, cursor)
        val afterCursor = line.text.substring(cursor)

        // Update current line
        line.updateFull(beforeCursor, beforeCursor.length)

        // Create new line with prefix continuation (only if cursor was past the prefix)
        if (cursor >= prefix.length) {
            createNewLineWithPrefix(lineIndex, afterCursor, prefix)
        } else {
            // Cursor within prefix, don't continue prefix
            state.lines.add(lineIndex + 1, LineState(afterCursor, 0))
            state.focusedLineIndex = lineIndex + 1
            state.requestFocusUpdate()
            state.notifyChange()
        }

        // Continue pending state on new line (groups Enter + subsequent typing)
        undoManager.continueAfterStructuralChange(state.focusedLineIndex)
    }

    /**
     * Merge current line with previous line.
     * Creates an undo boundary before the merge.
     */
    fun mergeToPreviousLine(lineIndex: Int) {
        if (lineIndex <= 0) return

        // Always capture state before merge - line merge is always undoable
        undoManager.captureStateBeforeChange(state)

        state.clearSelection()
        val currentLine = state.lines.getOrNull(lineIndex) ?: return
        val previousLine = state.lines.getOrNull(lineIndex - 1) ?: return

        val previousLength = previousLine.text.length
        previousLine.updateFull(previousLine.text + currentLine.text, previousLength)
        state.lines.removeAt(lineIndex)
        state.focusedLineIndex = lineIndex - 1
        state.requestFocusUpdate()
        state.notifyChange()

        // Begin editing the merged line
        undoManager.beginEditingLine(state, state.focusedLineIndex)
    }

    /**
     * Merge next line into current line.
     * Creates an undo boundary before the merge.
     */
    fun mergeNextLine(lineIndex: Int) {
        if (lineIndex >= state.lines.lastIndex) return

        // Always capture state before merge - line merge is always undoable
        undoManager.captureStateBeforeChange(state)

        state.clearSelection()
        val currentLine = state.lines.getOrNull(lineIndex) ?: return
        val nextLine = state.lines.getOrNull(lineIndex + 1) ?: return

        val currentLength = currentLine.text.length
        currentLine.updateFull(currentLine.text + nextLine.text, currentLength)
        state.lines.removeAt(lineIndex + 1)
        state.requestFocusUpdate()
        state.notifyChange()

        // Begin editing the merged line
        undoManager.beginEditingLine(state, state.focusedLineIndex)
    }

    // =========================================================================
    // Cursor Operations
    // =========================================================================

    /**
     * Set cursor position within a line.
     * Properly handles undo state when focus changes.
     */
    fun setCursor(lineIndex: Int, position: Int) {
        val line = state.lines.getOrNull(lineIndex) ?: return
        // Handle undo state when changing lines
        if (lineIndex != state.focusedLineIndex) {
            undoManager.commitPendingUndoState(state)
            state.focusedLineIndex = lineIndex
            undoManager.beginEditingLine(state, lineIndex)
        } else {
            state.focusedLineIndex = lineIndex
        }
        line.updateFull(line.text, position.coerceIn(0, line.text.length))
        state.clearSelection()
        state.requestFocusUpdate()
    }

    /**
     * Set cursor from global character offset.
     * Properly handles undo state when focus changes.
     */
    fun setCursorFromGlobalOffset(globalOffset: Int) {
        state.clearSelection()
        val (lineIndex, localOffset) = state.getLineAndLocalOffset(globalOffset)
        // Handle undo state when changing lines
        if (lineIndex != state.focusedLineIndex) {
            undoManager.commitPendingUndoState(state)
            state.focusedLineIndex = lineIndex
            undoManager.beginEditingLine(state, lineIndex)
        } else {
            state.focusedLineIndex = lineIndex
        }
        val line = state.lines.getOrNull(lineIndex) ?: return
        line.updateFull(line.text, localOffset)
        state.requestFocusUpdate()
    }

    // =========================================================================
    // Content Update (for composing text / IME sync)
    // =========================================================================

    /**
     * Update line content directly (used by IME for composing text).
     * This replaces the content portion while preserving the prefix.
     *
     * IMPORTANT: This is a direct content update from IME. Any selection should be
     * cleared first by the caller if needed. We don't try to be clever about
     * selection replacement here - that led to bugs.
     */
    fun updateLineContent(lineIndex: Int, newContent: String, contentCursor: Int) {
        val line = state.lines.getOrNull(lineIndex) ?: return

        // Check if this is a newline insertion
        if (newContent.contains('\n')) {
            // Prepare for structural change - commits prior typing, captures pre-split state
            undoManager.prepareForStructuralChange(state)

            state.clearSelection()
            val newlineIndex = newContent.indexOf('\n')
            val beforeNewline = newContent.substring(0, newlineIndex)
            val afterNewline = newContent.substring(newlineIndex + 1)

            // Update current line with content before newline
            line.updateContent(beforeNewline, beforeNewline.length)

            // Create new line with prefix continuation
            createNewLineWithPrefix(lineIndex, afterNewline, line.prefix)

            // Continue pending state on new line (groups Enter + subsequent typing)
            undoManager.continueAfterStructuralChange(state.focusedLineIndex)
            return
        }

        // Clear selection on any content update from IME
        // The old selection-replacement logic was causing bugs (like "Jg" → "Hg")
        // because it tried to extract inserted text and could corrupt content
        state.clearSelection()

        // Normal content update
        line.updateContent(newContent, contentCursor)
        state.notifyChange()

        // Mark that content has changed so canUndo reflects uncommitted edits
        undoManager.markContentChanged()
    }

    // =========================================================================
    // Focus Management
    // =========================================================================

    /**
     * Set focus to a specific line.
     * Triggers undo boundary when focus changes to a different line.
     */
    fun focusLine(lineIndex: Int) {
        if (lineIndex in state.lines.indices) {
            if (lineIndex != state.focusedLineIndex) {
                undoManager.commitPendingUndoState(state)
                state.focusedLineIndex = lineIndex
                undoManager.beginEditingLine(state, lineIndex)
            } else {
                state.focusedLineIndex = lineIndex
            }
            state.requestFocusUpdate()
        }
    }

    // =========================================================================
    // Selection Operations
    // =========================================================================

    /**
     * Check if there's an active selection.
     */
    fun hasSelection(): Boolean = state.hasSelection

    /**
     * Set selection range using global character offsets.
     * If start == end, this clears selection and sets cursor.
     */
    fun setSelection(start: Int, end: Int) {
        if (start == end) {
            setCursorFromGlobalOffset(start)
        } else {
            state.setSelection(start, end)
        }
    }

    /**
     * Set selection within a line using local content positions.
     * Converts local positions to global offsets and sets selection.
     *
     * @param lineIndex The line containing the selection
     * @param contentStart Start position within content (0 = first char after prefix)
     * @param contentEnd End position within content
     */
    fun setSelectionInLine(lineIndex: Int, contentStart: Int, contentEnd: Int) {
        val line = state.lines.getOrNull(lineIndex) ?: return
        val lineStart = state.getLineStartOffset(lineIndex)
        val prefixLength = line.prefix.length
        val contentLength = line.content.length

        val globalStart = lineStart + prefixLength + contentStart.coerceIn(0, contentLength)
        val globalEnd = lineStart + prefixLength + contentEnd.coerceIn(0, contentLength)

        if (globalStart == globalEnd) {
            setCursorFromGlobalOffset(globalStart)
        } else {
            state.setSelection(globalStart, globalEnd)
        }
    }

    /**
     * Handles space key when there's a selection.
     * Single space indents, double-space (within 250ms) unindents.
     * Creates an undo point so the indent/unindent can be undone.
     *
     * @return true if the space was handled (there was a selection), false otherwise
     */
    fun handleSpaceWithSelection(): Boolean {
        if (!state.hasSelection) return false
        // Use indent command type for grouping - consecutive space presses are grouped
        undoManager.recordCommand(state, CommandType.INDENT)
        return state.handleSpaceWithSelectionInternal()
    }

    /**
     * Replace the current selection with text (no undo handling).
     * If there's no selection, this is a no-op.
     * INTERNAL: Use paste() for proper undo handling.
     */
    internal fun replaceSelectionNoUndo(text: String) {
        if (state.hasSelection) {
            state.replaceSelectionInternal(text)
        }
    }

    /**
     * Delete the current selection (no undo handling).
     * INTERNAL: Use deleteSelectionWithUndo() for proper undo handling.
     */
    internal fun deleteSelectionNoUndo() {
        if (state.hasSelection) {
            state.deleteSelectionInternal()
        }
    }

    // =========================================================================
    // Line Prefix Operations
    // =========================================================================

    /**
     * Toggle checkbox state on a specific line (checked ↔ unchecked).
     * Does not add or remove the checkbox, only toggles existing ones.
     * Creates an undo point so the toggle can be undone.
     * Uses same undo pattern as command bar checkbox for consistency.
     */
    fun toggleCheckboxOnLine(lineIndex: Int) {
        val line = state.lines.getOrNull(lineIndex) ?: return
        // Use same undo pattern as command bar checkbox toggle
        undoManager.recordCommand(state, CommandType.CHECKBOX)
        line.toggleCheckboxState()
        undoManager.commitAfterCommand(state, CommandType.CHECKBOX)
        state.requestFocusUpdate()
        state.notifyChange()
    }

    // =========================================================================
    // Read Access
    // =========================================================================

    /**
     * Get the current text of a line.
     */
    fun getLineText(lineIndex: Int): String = state.lines.getOrNull(lineIndex)?.text ?: ""

    /**
     * Get the content (without prefix) of a line.
     */
    fun getLineContent(lineIndex: Int): String = state.lines.getOrNull(lineIndex)?.content ?: ""

    /**
     * Get the cursor position within a line's content.
     */
    fun getContentCursor(lineIndex: Int): Int = state.lines.getOrNull(lineIndex)?.contentCursorPosition ?: 0

    /**
     * Get the full cursor position within a line.
     */
    fun getLineCursor(lineIndex: Int): Int = state.lines.getOrNull(lineIndex)?.cursorPosition ?: 0

    /**
     * Check if a line index is valid.
     */
    fun isValidLine(lineIndex: Int): Boolean = lineIndex in state.lines.indices
}

/**
 * Remember an EditorController for the given EditorState.
 */
@Composable
fun rememberEditorController(state: EditorState): EditorController {
    return remember(state) { EditorController(state) }
}
