package org.alkaline.taskbrain.dsl.directives

import org.alkaline.taskbrain.data.Note
import org.alkaline.taskbrain.dsl.language.IdempotencyAnalyzer
import org.alkaline.taskbrain.dsl.language.Lexer
import org.alkaline.taskbrain.dsl.language.LexerException
import org.alkaline.taskbrain.dsl.language.ParseException
import org.alkaline.taskbrain.dsl.language.Parser
import org.alkaline.taskbrain.dsl.runtime.Environment
import org.alkaline.taskbrain.dsl.runtime.ExecutionException
import org.alkaline.taskbrain.dsl.runtime.Executor
import org.alkaline.taskbrain.dsl.runtime.LambdaVal
import org.alkaline.taskbrain.dsl.runtime.NoteContext
import org.alkaline.taskbrain.dsl.runtime.NoteMutation
import org.alkaline.taskbrain.dsl.runtime.NoteOperations
import org.alkaline.taskbrain.dsl.runtime.PatternVal

/**
 * Result of executing a directive, including any mutations that occurred.
 * The result is for storage/display; mutations are for propagating changes.
 */
data class DirectiveExecutionResult(
    val result: DirectiveResult,
    val mutations: List<NoteMutation>
)

/**
 * Utility for finding directives in note content.
 *
 * A directive is text enclosed in square brackets: [...]
 * Milestone 1: Simple non-nested matching with \[.*?\]
 * Milestone 6: Adds current note context for [.] reference.
 * Milestone 7: Adds note operations for mutations.
 */
object DirectiveFinder {

    /**
     * Creates a unique key for a directive based on its position.
     * This ensures each directive instance has its own cached result,
     * even if multiple directives have the same text (e.g., two [now] directives).
     *
     * @param lineIndex The line number (0-indexed) where the directive appears
     * @param startOffset The character offset within the line where the directive starts
     * @return A string key like "3:15" for line 3, offset 15
     */
    fun directiveKey(lineIndex: Int, startOffset: Int): String = "$lineIndex:$startOffset"

    /**
     * A located directive in note content.
     *
     * @property sourceText The full directive text including brackets
     * @property startOffset The character offset where the directive starts
     * @property endOffset The character offset where the directive ends (exclusive)
     */
    data class FoundDirective(
        val sourceText: String,
        val startOffset: Int,
        val endOffset: Int
    ) {
        /**
         * Compute a hash for this directive for storage lookups.
         */
        fun hash(): String = DirectiveResult.hashDirective(sourceText)
    }

    /**
     * Find all directives in the given content.
     * Handles nested brackets for lambda syntax: [lambda[...]]
     *
     * Milestone 8: Updated to support nested brackets.
     *
     * @param content The note content to search
     * @return List of found directives in order of appearance
     */
    fun findDirectives(content: String): List<FoundDirective> {
        val directives = mutableListOf<FoundDirective>()
        var i = 0

        while (i < content.length) {
            if (content[i] == '[') {
                val startOffset = i
                var depth = 1
                i++

                // Find matching closing bracket, tracking nesting depth
                while (i < content.length && depth > 0) {
                    when (content[i]) {
                        '[' -> depth++
                        ']' -> depth--
                    }
                    i++
                }

                // Only add if we found a matching closing bracket
                if (depth == 0) {
                    directives.add(
                        FoundDirective(
                            sourceText = content.substring(startOffset, i),
                            startOffset = startOffset,
                            endOffset = i
                        )
                    )
                }
            } else {
                i++
            }
        }

        return directives
    }

    /**
     * Check if the given text contains any directives.
     */
    fun containsDirectives(content: String): Boolean {
        return findDirectives(content).isNotEmpty()
    }

    /**
     * Parse and execute a single directive, returning the result and any mutations.
     *
     * @param sourceText The directive source text (including brackets)
     * @param notes Optional list of notes for find() operations
     * @param currentNote Optional current note for [.] reference (Milestone 6)
     * @param noteOperations Optional note operations for mutations (Milestone 7)
     * @return DirectiveExecutionResult containing the result and any mutations that occurred
     */
    fun executeDirective(
        sourceText: String,
        notes: List<Note>? = null,
        currentNote: Note? = null,
        noteOperations: NoteOperations? = null
    ): DirectiveExecutionResult {
        val env = createEnvironment(notes, currentNote, noteOperations)
        return try {
            val tokens = Lexer(sourceText).tokenize()
            val directive = Parser(tokens, sourceText).parseDirective()

            // Check idempotency before execution
            val idempotencyResult = IdempotencyAnalyzer.analyze(directive.expression)
            if (!idempotencyResult.isIdempotent) {
                return DirectiveExecutionResult(
                    DirectiveResult.failure(idempotencyResult.nonIdempotentReason ?: "Non-idempotent operation"),
                    emptyList()
                )
            }

            val value = Executor().execute(directive, env)

            // Check for no-effect values that can't be meaningfully displayed
            val warningType = checkNoEffectValue(value)
            if (warningType != null) {
                return DirectiveExecutionResult(
                    DirectiveResult.warning(warningType),
                    env.getMutations()
                )
            }

            DirectiveExecutionResult(DirectiveResult.success(value), env.getMutations())
        } catch (e: LexerException) {
            DirectiveExecutionResult(DirectiveResult.failure("Lexer error: ${e.message}"), env.getMutations())
        } catch (e: ParseException) {
            DirectiveExecutionResult(DirectiveResult.failure("Parse error: ${e.message}"), env.getMutations())
        } catch (e: ExecutionException) {
            DirectiveExecutionResult(DirectiveResult.failure("Execution error: ${e.message}"), env.getMutations())
        } catch (e: Exception) {
            DirectiveExecutionResult(DirectiveResult.failure("Unexpected error: ${e.message}"), env.getMutations())
        }
    }

    /**
     * Create an environment with the appropriate context.
     */
    private fun createEnvironment(
        notes: List<Note>?,
        currentNote: Note?,
        noteOperations: NoteOperations?
    ): Environment {
        return Environment(NoteContext(notes, currentNote, noteOperations))
    }

    /**
     * Check if a value is a no-effect value that produces a warning.
     * These are values that can't be meaningfully displayed or stored.
     *
     * Milestone 8.
     */
    private fun checkNoEffectValue(value: org.alkaline.taskbrain.dsl.runtime.DslValue): DirectiveWarningType? {
        return when (value) {
            is LambdaVal -> DirectiveWarningType.NO_EFFECT_LAMBDA
            is PatternVal -> DirectiveWarningType.NO_EFFECT_PATTERN
            else -> null
        }
    }

    /**
     * Find, parse, and execute all directives in the content.
     *
     * @param content The note content (single line)
     * @param lineIndex The line index (for position-based keys)
     * @param notes Optional list of notes for find() operations
     * @param currentNote Optional current note for [.] reference (Milestone 6)
     * @return Map of directive position key to execution result
     */
    fun executeAllDirectives(
        content: String,
        lineIndex: Int,
        notes: List<Note>? = null,
        currentNote: Note? = null
    ): Map<String, DirectiveResult> {
        return findDirectives(content).associate { found ->
            directiveKey(lineIndex, found.startOffset) to
                executeDirective(found.sourceText, notes, currentNote).result
        }
    }
}
